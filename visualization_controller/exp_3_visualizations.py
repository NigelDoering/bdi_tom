"""Visualization utilities for Experiment 3 metrics."""

from __future__ import annotations

import argparse
import json
from pathlib import Path
from typing import Dict, List, Mapping, Sequence, Tuple

import matplotlib.pyplot as plt


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Render Experiment 3 evaluation plots.")
    parser.add_argument(
        "--summary",
        type=Path,
        default=Path("data/simulation_data/run_1/visualizations/exp_3/exp_3_summary.json"),
        help="Path to exp_3_summary.json generated by exp_3_eval.py.",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=None,
        help="Optional directory for plots (defaults to summary parent directory).",
    )
    return parser.parse_args()


def load_summary(summary_path: Path) -> Dict[str, object]:
    with summary_path.open("r", encoding="utf-8") as fh:
        return json.load(fh)


def _collect_fractions(result_entry: Mapping[str, object], key: str) -> List[float]:
    phase_map = result_entry.get(key, {})
    return sorted(float(fraction) for fraction in phase_map.keys())


def extract_series(summary: Mapping[str, object]) -> Tuple[List[Dict[str, object]], List[float], List[float]]:
    results = summary.get("results", [])
    if not results:
        return [], [], []
    first = results[0]
    pre_fractions = _collect_fractions(first, "pre_phase")
    post_fractions = _collect_fractions(first, "post_phase")
    return results, pre_fractions, post_fractions


def plot_phase_curves(
    output_path: Path,
    title: str,
    ylabel: str,
    fractions: Sequence[float],
    results: Sequence[Mapping[str, object]],
    phase_key: str,
) -> None:
    if not fractions:
        return

    plt.figure(figsize=(8, 5))
    x_ticks = [fraction * 100 for fraction in fractions]

    for entry in results:
        model_name = entry["model"]
        phase_data = entry[phase_key]
        means = [phase_data[str(fraction)]["mean"] for fraction in fractions]
        ci_low = [phase_data[str(fraction)]["ci_low"] for fraction in fractions]
        ci_high = [phase_data[str(fraction)]["ci_high"] for fraction in fractions]

        lower_err = [max(0.0, mean - low) if low is not None else 0.0 for mean, low in zip(means, ci_low)]
        upper_err = [max(0.0, high - mean) if high is not None else 0.0 for mean, high in zip(means, ci_high)]

        plt.plot(x_ticks, means, marker="o", linewidth=2, label=model_name)
        lower_band = [mean - err for mean, err in zip(means, lower_err)]
        upper_band = [mean + err for mean, err in zip(means, upper_err)]
        plt.fill_between(x_ticks, lower_band, upper_band, alpha=0.2)

    plt.title(title)
    plt.xlabel("Trajectory Observed (%)")
    plt.ylabel(ylabel)
    plt.grid(alpha=0.3)
    plt.xticks(x_ticks)
    plt.legend()
    plt.tight_layout()
    plt.savefig(output_path, dpi=300, bbox_inches="tight")
    plt.close()


def plot_post_entropy(
    output_path: Path,
    fractions: Sequence[float],
    results: Sequence[Mapping[str, object]],
) -> None:
    if not fractions:
        return

    plt.figure(figsize=(8, 5))
    x_ticks = [fraction * 100 for fraction in fractions]

    for entry in results:
        model_name = entry["model"]
        entropy_data = entry["post_entropy"]
        means = [entropy_data[str(fraction)]["mean"] for fraction in fractions]
        ci_low = [entropy_data[str(fraction)]["ci_low"] for fraction in fractions]
        ci_high = [entropy_data[str(fraction)]["ci_high"] for fraction in fractions]

        lower_err = [max(0.0, mean - low) if low is not None else 0.0 for mean, low in zip(means, ci_low)]
        upper_err = [max(0.0, high - mean) if high is not None else 0.0 for mean, high in zip(means, ci_high)]

        plt.plot(x_ticks, means, marker="o", linewidth=2, label=model_name)
        lower_band = [mean - err for mean, err in zip(means, lower_err)]
        upper_band = [mean + err for mean, err in zip(means, upper_err)]
        plt.fill_between(x_ticks, lower_band, upper_band, alpha=0.2)

    plt.title("Post-pivot Entropy vs. Observation")
    plt.xlabel("Trajectory Observed (%)")
    plt.ylabel("Predictive Entropy")
    plt.grid(alpha=0.3)
    plt.xticks(x_ticks)
    plt.legend()
    plt.tight_layout()
    plt.savefig(output_path, dpi=300, bbox_inches="tight")
    plt.close()


def plot_scalar_metrics(output_path: Path, results: Sequence[Mapping[str, object]]) -> None:
    if not results:
        return

    plt.figure(figsize=(6, 5))
    model_names = [entry["model"] for entry in results]
    belief_means = [entry["belief_alignment"]["mean"] for entry in results]
    belief_low = [entry["belief_alignment"]["ci_low"] for entry in results]
    belief_high = [entry["belief_alignment"]["ci_high"] for entry in results]

    adapt_means = [entry["adaptation_speed"]["mean"] for entry in results]
    adapt_low = [entry["adaptation_speed"]["ci_low"] for entry in results]
    adapt_high = [entry["adaptation_speed"]["ci_high"] for entry in results]

    x = range(len(model_names))
    width = 0.35

    belief_err = [
        [max(0.0, mean - low) if low is not None else 0.0 for mean, low in zip(belief_means, belief_low)],
        [max(0.0, high - mean) if high is not None else 0.0 for mean, high in zip(belief_means, belief_high)],
    ]
    adapt_err = [
        [max(0.0, mean - low) if low is not None else 0.0 for mean, low in zip(adapt_means, adapt_low)],
        [max(0.0, high - mean) if high is not None else 0.0 for mean, high in zip(adapt_means, adapt_high)],
    ]

    plt.bar([pos - width / 2 for pos in x], belief_means, width=width, label="Belief Alignment", yerr=belief_err, capsize=6)
    plt.bar([pos + width / 2 for pos in x], adapt_means, width=width, label="Adaptation Speed", yerr=adapt_err, capsize=6)

    plt.xticks(list(x), model_names, rotation=15)
    plt.ylabel("Metric Value")
    plt.title("Experiment 3 Scalar Metrics")
    plt.legend()
    plt.tight_layout()
    plt.savefig(output_path, dpi=300, bbox_inches="tight")
    plt.close()


def plot_phase_boxplots(
    output_path: Path,
    fractions: Sequence[float],
    results: Sequence[Mapping[str, object]],
    phase_key: str,
    title: str,
    ylabel: str,
) -> None:
    if not fractions:
        return

    for entry in results:
        model_name = entry["model"]
        phase_data = entry[phase_key]
        plt.figure(figsize=(8, 5))
        data = [phase_data[str(fraction)]["values"] for fraction in fractions]
        labels = [f"{int(fraction * 100)}%" for fraction in fractions]
        bp = plt.boxplot(data, tick_labels=labels, patch_artist=True)
        for patch in bp["boxes"]:
            patch.set_alpha(0.6)
            patch.set_facecolor("#1f77b4")
        plt.title(f"{title} — {model_name}")
        plt.xlabel("Trajectory Observed")
        plt.ylabel(ylabel)
        plt.grid(axis="y", alpha=0.3)
        plt.tight_layout()
        plt.savefig(output_path.with_name(f"{output_path.stem}_{model_name}.png"), dpi=300, bbox_inches="tight")
        plt.close()


def plot_pre_post_comparison(
    output_path: Path,
    fractions: Sequence[float],
    results: Sequence[Mapping[str, object]],
) -> None:
    if not fractions:
        return

    for entry in results:
        model_name = entry["model"]
        pre = entry["pre_phase"]
        post = entry["post_phase"]
        indices = range(len(fractions))
        width = 0.35
        plt.figure(figsize=(8, 5))
        pre_means = [pre[str(fraction)]["mean"] for fraction in fractions]
        post_means = [post[str(fraction)]["mean"] for fraction in fractions]
        plt.bar([idx - width / 2 for idx in indices], pre_means, width=width, label="Pre-Pivot", alpha=0.8)
        plt.bar([idx + width / 2 for idx in indices], post_means, width=width, label="Post-Pivot", alpha=0.8)
        for idx, (pre_mean, post_mean) in enumerate(zip(pre_means, post_means)):
            plt.annotate(f"{pre_mean:.3f}", (idx - width / 2, pre_mean), textcoords="offset points", xytext=(0, 5), ha="center", fontsize=8)
            plt.annotate(f"{post_mean:.3f}", (idx + width / 2, post_mean), textcoords="offset points", xytext=(0, 5), ha="center", fontsize=8)
        plt.xticks(list(indices), [f"{int(fraction * 100)}%" for fraction in fractions])
        plt.ylabel("Goal Probability")
        plt.title(f"Pre vs Post Goal Probability Comparison — {model_name}")
        plt.legend()
        plt.grid(axis="y", alpha=0.3)
        plt.tight_layout()
        plt.savefig(output_path.with_name(f"{output_path.stem}_{model_name}.png"), dpi=300, bbox_inches="tight")
        plt.close()


def plot_entropy_histogram(output_path: Path, results: Sequence[Mapping[str, object]]) -> None:
    if not results:
        return

    for entry in results:
        model_name = entry["model"]
        entropy_values: List[float] = []
        for fraction_data in entry["post_entropy"].values():
            entropy_values.extend(fraction_data["values"])
        plt.figure(figsize=(8, 5))
        plt.hist(entropy_values, bins=10, color="#ff7f0e", alpha=0.75, edgecolor="black")
        plt.axvline(sum(entropy_values) / len(entropy_values), color="black", linestyle="--", linewidth=1.5, label="Mean")
        plt.title(f"Distribution of Post-Pivot Entropy — {model_name}")
        plt.xlabel("Predictive Entropy")
        plt.ylabel("Frequency")
        plt.legend()
        plt.grid(alpha=0.3)
        plt.tight_layout()
        plt.savefig(output_path.with_name(f"{output_path.stem}_{model_name}.png"), dpi=300, bbox_inches="tight")
        plt.close()


def main() -> None:
    args = parse_args()
    summary = load_summary(args.summary)

    results, pre_fractions, post_fractions = extract_series(summary)
    if not results:
        print("No Experiment 3 results available for plotting.")
        return

    output_dir = args.output or args.summary.parent
    output_dir.mkdir(parents=True, exist_ok=True)

    plot_phase_curves(
        output_dir / "exp_3_pre_phase_goal_probs.png",
        "Pre-pivot Goal Probability vs. Observation",
        "Goal Probability (First Goal)",
        pre_fractions,
        results,
        phase_key="pre_phase",
    )

    plot_phase_curves(
        output_dir / "exp_3_post_phase_goal_probs.png",
        "Post-pivot Goal Probability vs. Observation",
        "Goal Probability (Replanned Goal)",
        post_fractions,
        results,
        phase_key="post_phase",
    )

    plot_post_entropy(output_dir / "exp_3_post_phase_entropy.png", post_fractions, results)
    plot_scalar_metrics(output_dir / "exp_3_scalar_metrics.png", results)
    plot_phase_boxplots(
        output_dir / "exp_3_pre_phase_boxplot.png",
        pre_fractions,
        results,
        phase_key="pre_phase",
        title="Pre-pivot Goal Probability Distribution",
        ylabel="Goal Probability",
    )
    plot_phase_boxplots(
        output_dir / "exp_3_post_phase_boxplot.png",
        post_fractions,
        results,
        phase_key="post_phase",
        title="Post-pivot Goal Probability Distribution",
        ylabel="Goal Probability",
    )
    plot_pre_post_comparison(
        output_dir / "exp_3_pre_post_comparison.png",
        pre_fractions,
        results,
    )
    plot_entropy_histogram(output_dir / "exp_3_post_entropy_histogram.png", results)

    print(f"Saved Experiment 3 plots to {output_dir}")


if __name__ == "__main__":
    main()
